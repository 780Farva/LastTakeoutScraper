#!/usr/bin/env bash
# This script was generated by bashly 1.2.10 (https://bashly.dev)
# Modifying it manually is not recommended

if [[ "${BASH_VERSINFO:-0}" -lt 4 ]]; then
  printf "bash version 4 or higher is required\n" >&2
  exit 1
fi

root_command() {
  log info "~*~*~*~ LastTakeoutScraper ~*~*~*~"
  # Give ourselves a temporary file to work with
  # tmp_folder=/tmp/lts/$(uuidgen)
  # tmp_folder=/tmp/lts/
  tmp_folder=./tmp/lts
  music_entries_only_file=${tmp_folder}/music_only.json
  unique_artist_tracks=${tmp_folder}/artist_tracks.json
  tagged_uniques=${tmp_folder}/tagged_artist_tracks.json

  log info "I'll read from ${args[source]}, make some temporary files in ${tmp_folder} and write my results to ${args[out]}"

  mkdir -p $tmp_folder

  jq '[.[] | select(.header == "YouTube Music") |
  	select(has("subtitles")) |
  	.artist = (.subtitles[].name) |
  	.artist |= (sub(" - Topic"; "") | gsub("^\\s+|\\s+$"; "") ) |
  	. += { uts: (.time | sub("\\.[[:digit:]]+"; "") | fromdateiso8601 ) } |
  	. += { utc_time: .time} |
  	. += { track: (.title | sub("Watched "; ""))} |
  	del(.header, .time, .title, .activityControls, .titleUrl, .products, .subtitles)]' \
  	${args[source]} > ${music_entries_only_file}

  log debug "A music-only version of the input file has been written to ${music_entries_only_file}"

  log debug "Collecting unique artist-track pairs..."
  jq -c 'unique_by([ .artist, .track ]) | .[] | del(.uts,.utc_time)' ${music_entries_only_file} > ${unique_artist_tracks}

  exit 0

  # a function that gets additional track information from musicbrainz
  # usage get-mb-data <track_name> <artist_name>
  function get-mb-data () {
  mb_result=$(curl -s --get \
  --data-urlencode 'fmt=json' \
  --data-urlencode 'limit=1' \
  --data-urlencode "query=\"$1\" AND artist:\"$2\"" \
  'https://musicbrainz.org/ws/2/recording/')

  echo $mb_result | jq -c -M 'select(.count != 0) |
  . += {
  		track: ( .recordings[0].title ),
  	  track_mbid: ( .recordings[0].id ),
  		artist: ( .recordings[0]."artist-credit"[0].name),
  		artist_mbid: ( .recordings[0]."artist-credit"[0].artist.id),
  		album: ( .recordings[0].releases[0].title ),
  		album_mbid: ( .recordings[0].releases[0].id )} |
  del(.created, .count, .offset, .recordings)'
  }

  # use those artist names to get info from musicbrainz
  log info "Retrieving album data..."
  echo "[" > $tagged_uniques
  jq -c '.[]' < $unique_artist_tracks | while read -r line; do
    artist_name=$(echo "$line" | jq -r '.artist')
    track_name=$(echo "$line" | jq -r '.track')
  		log debug  $artist_name $track_name
    recording=$(get-mb-data "$track_name" "$artist_name")
    if [[ -n $recording ]]; then
      # Capture the result into a new file
  		log debug "."
      echo "${recording}," >> $tagged_uniques
    fi
  done

  # echo "uts,utc_time,artist,track" > ${args[out]}
  # jq -r '.[] | [.uts, .utc_time, .artist, .track] | @csv' \
  # 	${music_entries_only_file} >> ${args[out]}

  log info "~*~*~*~ fin ~*~*~*~"
}

version_command() {
  echo "$version"
}

lts_usage() {
  printf "lts - Convert Google Takeout dumps of YouTube Music listening history to a CSV of scrobbles in the same format as last.fm data dumps. Prints to stdout\n\n"

  printf "%s\n" "Usage:"
  printf "  lts SOURCE OUT\n"
  printf "  lts --help | -h\n"
  printf "  lts --version | -v\n"
  echo

  if [[ -n "$long_usage" ]]; then
    printf "%s\n" "Options:"

    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo
    printf "  %s\n" "--version, -v"
    printf "    Show version number\n"
    echo

    printf "%s\n" "Arguments:"

    printf "  %s\n" "SOURCE"
    printf "    Path to your watch-history.json file.\n"
    echo

    printf "  %s\n" "OUT"
    printf "    Path where the resulting csv of scrobbles will be written.\n"
    echo

    printf "%s\n" "Examples:"
    printf "  lts ./watch-history.json ./scrobbles.csv\n"
    printf "  DEBUG=1 lts ./watch-history.json ./scrobbles.csv\n"
    echo

  fi
}

normalize_input() {
  local arg passthru flags
  passthru=false

  while [[ $# -gt 0 ]]; do
    arg="$1"
    if [[ $passthru == true ]]; then
      input+=("$arg")
    elif [[ $arg =~ ^(--[a-zA-Z0-9_\-]+)=(.+)$ ]]; then
      input+=("${BASH_REMATCH[1]}")
      input+=("${BASH_REMATCH[2]}")
    elif [[ $arg =~ ^(-[a-zA-Z0-9])=(.+)$ ]]; then
      input+=("${BASH_REMATCH[1]}")
      input+=("${BASH_REMATCH[2]}")
    elif [[ $arg =~ ^-([a-zA-Z0-9][a-zA-Z0-9]+)$ ]]; then
      flags="${BASH_REMATCH[1]}"
      for ((i = 0; i < ${#flags}; i++)); do
        input+=("-${flags:i:1}")
      done
    elif [[ "$arg" == "--" ]]; then
      passthru=true
      input+=("$arg")
    else
      input+=("$arg")
    fi

    shift
  done
}

function _log_exception() {
  (
    BASHLOG_FILE=0;
    BASHLOG_JSON=0;
    BASHLOG_SYSLOG=0;

    log 'error' "Logging Exception: ${@}";
  );
}

function log() {
  local date_format="${BASHLOG_DATE_FORMAT:-+%F %T}";
  local date="$(date "${date_format}")";
  local date_s="$(date "+%s")";

  local file="${BASHLOG_FILE:-0}";
  local file_path="${BASHLOG_FILE_PATH:-/tmp/$(basename "${0}").log}";

  local json="${BASHLOG_JSON:-0}";
  local json_path="${BASHLOG_JSON_PATH:-/tmp/$(basename "${0}").log.json}";

  local syslog="${BASHLOG_SYSLOG:-0}";
  local tag="${BASHLOG_SYSLOG_TAG:-$(basename "${0}")}";
  local facility="${BASHLOG_SYSLOG_FACILITY:-local0}";
  local pid="${$}";

  local level="${1}";
  local upper="$(echo "${level}" | awk '{print toupper($0)}')";
  local debug_level="${DEBUG:-0}";

  shift 1;

  local line="${@}";

  # RFC 5424
  #
  # Numerical         Severity
  #   Code
  #
  #    0       Emergency: system is unusable
  #    1       Alert: action must be taken immediately
  #    2       Critical: critical conditions
  #    3       Error: error conditions
  #    4       Warning: warning conditions
  #    5       Notice: normal but significant condition
  #    6       Informational: informational messages
  #    7       Debug: debug-level messages

  local -A severities;
  severities['DEBUG']=7;
  severities['INFO']=6;
  severities['NOTICE']=5; # Unused
  severities['WARN']=4;
  severities['ERROR']=3;
  severities['CRIT']=2;   # Unused
  severities['ALERT']=1;  # Unused
  severities['EMERG']=0;  # Unused

  local severity="${severities[${upper}]:-3}"

  if [ "${debug_level}" -gt 0 ] || [ "${severity}" -lt 7 ]; then

    if [ "${syslog}" -eq 1 ]; then
      local syslog_line="${upper}: ${line}";

      logger \
        --id="${pid}" \
        -t "${tag}" \
        -p "${facility}.${severity}" \
        "${syslog_line}" \
        || _log_exception "logger --id=\"${pid}\" -t \"${tag}\" -p \"${facility}.${severity}\" \"${syslog_line}\"";
    fi;

    if [ "${file}" -eq 1 ]; then
      local file_line="${date} [${upper}] ${line}";
      echo -e "${file_line}" >> "${file_path}" \
        || _log_exception "echo -e \"${file_line}\" >> \"${file_path}\"";
    fi;

    if [ "${json}" -eq 1 ]; then
      local json_line="$(printf '{"timestamp":"%s","level":"%s","message":"%s"}' "${date_s}" "${level}" "${line}")";
      echo -e "${json_line}" >> "${json_path}" \
        || _log_exception "echo -e \"${json_line}\" >> \"${json_path}\"";
    fi;

  fi;

  local -A colours;
  colours['DEBUG']='\033[34m'  # Blue
  colours['INFO']='\033[32m'   # Green
  colours['NOTICE']=''         # Unused
  colours['WARN']='\033[33m'   # Yellow
  colours['ERROR']='\033[31m'  # Red
  colours['CRIT']=''           # Unused
  colours['ALERT']=''          # Unused
  colours['EMERG']=''          # Unused
  colours['DEFAULT']='\033[0m' # Default

  local norm="${colours['DEFAULT']}";
  local colour="${colours[${upper}]:-\033[31m}";

  local std_line="${colour}${date} [${upper}] ${line}${norm}";

  # Standard Output (Pretty)
  case "${level}" in
    'info'|'warn')
      echo -e "${std_line}";
      ;;
    'debug')
      if [ "${debug_level}" -gt 0 ]; then
        echo -e "${std_line}";
      fi;
      ;;
    'error')
      echo -e "${std_line}" >&2;
      if [ "${debug_level}" -gt 0 ]; then
        echo -e "Here's a shell to debug with. 'exit 0' to continue. Other exit codes will abort - parent shell will terminate.";
        bash || exit "${?}";
      fi;
      ;;
    *)
      log 'error' "Undefined log level trying to log: ${@}";
      ;;
  esac
}

declare prev_cmd="null";
declare this_cmd="null";
trap 'prev_cmd=$this_cmd; this_cmd=$BASH_COMMAND' DEBUG \
  && log debug 'DEBUG trap set' \
  || log error 'DEBUG trap failed to set';

validate_file_exists() {
  [[ -f "$1" ]] || echo "must be an existing file"
}

validate_parent_dir_exists() {
  [[ -d "$(dirname $1)" ]] || echo "Parent directory of $1 does not exist."
}

parse_requirements() {

  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      --version | -v)
        version_command
        exit
        ;;

      --help | -h)
        long_usage=yes
        lts_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  action="root"

  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)

        if [[ -z ${args['source']+x} ]]; then
          args['source']=$1
          shift

        elif [[ -z ${args['out']+x} ]]; then
          args['out']=$1
          shift
        else
          printf "invalid argument: %s\n" "$key" >&2
          exit 1
        fi

        ;;

    esac
  done

  if [[ -z ${args['source']+x} ]]; then
    printf "missing required argument: SOURCE\nusage: lts SOURCE OUT\n" >&2

    exit 1
  fi

  if [[ -z ${args['out']+x} ]]; then
    printf "missing required argument: OUT\nusage: lts SOURCE OUT\n" >&2

    exit 1
  fi

  if [[ -v args['source'] && -n $(validate_file_exists "${args['source']:-}") ]]; then
    printf "validation error in %s:\n%s\n" "SOURCE" "$(validate_file_exists "${args['source']:-}")" >&2
    exit 1
  fi

  if [[ -v args['out'] && -n $(validate_parent_dir_exists "${args['out']:-}") ]]; then
    printf "validation error in %s:\n%s\n" "OUT" "$(validate_parent_dir_exists "${args['out']:-}")" >&2
    exit 1
  fi

}

initialize() {
  declare -g version="0.1.0"
  set -e

}

run() {

  declare -g long_usage=''
  declare -g -A args=()
  declare -g -A deps=()
  declare -g -a env_var_names=()
  declare -g -a input=()

  normalize_input "$@"
  parse_requirements "${input[@]}"

  case "$action" in
    "root") root_command ;;
  esac
}

initialize
run "$@"
